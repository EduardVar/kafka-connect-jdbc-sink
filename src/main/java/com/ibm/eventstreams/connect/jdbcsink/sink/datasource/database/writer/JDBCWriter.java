package com.ibm.eventstreams.connect.jdbcsink.sink.datasource.database.writer;

import com.google.gson.Gson;
import com.ibm.eventstreams.connect.jdbcsink.sink.JDBCSinkTask;
import com.ibm.eventstreams.connect.jdbcsink.sink.datasource.IDataSource;
import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.kafka.connect.sink.SinkRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.Collection;

public class JDBCWriter implements IDatabaseWriter{

    private static Gson gson = new Gson();

    private final boolean isInsertModeDatabaseLevelEnabled;

    private static final Logger log = LoggerFactory.getLogger(JDBCSinkTask.class);

    private final IDataSource datasource;

    // TODO: Use the strategy pattern with upsert strategies depending on the type of database being supported.
    //  Comma separated columns, values and relationships - nested json
    private static final String INSERT_STATEMENT = "INSERT INTO %s(%, %s, %s) VALUES (%s, %s, %s)";

    public JDBCWriter(final boolean insertModeDatabaseLevel, final IDataSource datasource) {
        this.isInsertModeDatabaseLevelEnabled = insertModeDatabaseLevel;
        this.datasource = datasource;
    }

    private boolean checkTable(String tableName){

        try (Connection connection = this.datasource.getConnection()) {
            connection.setAutoCommit(false);

            DatabaseMetaData dbm = connection.getMetaData();
            ResultSet table = dbm.getTables(null,null, tableName, null);

            return table.next();

        } catch (SQLException ex) {
            ex.printStackTrace();
        }

        return false;
    }

    public boolean createTable(String tableName) throws SQLException {

        final String CREATE_STATEMENT = "CREATE TABLE %s (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, key VARCHAR(32), timestamp VARCHAR(16), value TEXT);";

        try (Connection connection = this.datasource.getConnection()){
            Statement statement = connection.createStatement();

            final String createQuery = String.format(CREATE_STATEMENT, tableName);

            statement.execute(createQuery);
            log.warn("TABLE " + tableName + " has been created");

        } catch (SQLException ex) {
            ex.printStackTrace();
        }

        return true;
    }


    @Override
    public boolean insert(String tableName, Collection<SinkRecord> records) throws SQLException {
        // tableNameFormat must be processed
        // TODO: determine if we should externalize and maintain open connections
        //  under certain circumstances.
        try (Connection connection = this.datasource.getConnection()) {
            connection.setAutoCommit(false);

            log.warn("TABLE EXISTS = " + checkTable("company") + " TABLE EXISTS ");
            log.warn("TABLE EXISTS2 = " + checkTable("company2") + " TABLE EXISTS2 ");

            if (!checkTable(tableName)) {
                createTable(tableName);
            }

            // TODO: need an SQL statement builder with potential variations depending on the platform
            final String INSERT_STATEMENT = "INSERT INTO %s(key, timestamp, value) VALUES ('%s', %s, '%s');";
            Statement statement = connection.createStatement();

            //records.stream().map(log.warn)
            // TODO: we need to figure out how to map complex records into a relational database format.
            //  do we support a 1-to-1, 1-to-many, many-to-many, recursive structure on tables.
            records.forEach(record -> {
                // TODO: add record.key();
                // TODO: add record timestamp
                // TODO: key and value could be a string or a more complex object

                Object recordKey = gson.toJson(record.key());
                Long recordTimeStamp = record.timestamp();
                Object recordValue = gson.toJson(record.value());

                log.warn("recordKEY = " + recordKey);
                log.warn("recordVALUE = " + recordValue);

                log.warn("Record Value = " + record.toString() + " <-- Record Value");

                final String finalQuery = String.format(INSERT_STATEMENT, tableName, recordKey, recordTimeStamp, recordValue);
                log.info("RECORD INSERTED");
                log.info("Final prepared statement: '{}' //", finalQuery);

                try {
                    statement.addBatch(finalQuery);
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            });

            statement.executeBatch();
            connection.commit();

        }catch (SQLException e){
            e.printStackTrace();
        }
        return true;
    }
}